'''
924. Minimize Malware Spread

You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.

Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial.

Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

Note that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.
'''

'''
超时了
'''
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        res = (0, float('inf'))
        initial.sort()
        for node in initial:
            num = self.countNum(node, graph, initial)
            if num < res[1]:
                res = (node, num)
        return res[0]
    
    
    def countNum(self, node, graph, initial):
        gmap = set()
        def helper(n, net):
            net.add(n)
            for i in range(len(graph)):
                if graph[n][i] and i not in net:
                    helper(i, net)
            return net
            
        for n in initial:
            if node != n:
                 gmap = gmap.union(helper(n, set()))
        # print(node, gmap)              
        return len(gmap)

'''
so 土法炼钢，还挺快的
需要net和visited同时存在，visited是总的，net是分的。
每一个i只能在一个网中，所以visited总的它只能一次。visited的作用是剪枝

'''
# faster than 91.94% of Python3
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        gmap = []
        n = len(graph)
        visited = [0] * n
        def dfs(i, net):
            if visited[i]:
                return
            visited[i] = 1
            for j in range(n):
                if graph[i][j] and j not in net:
                    net.add(j)
                    dfs(j, net)           
            return net
        
        for i in range(n):
            net = dfs(i, set())
            net and gmap.append(net)
        print(gmap)
        
        count = defaultdict(set)
        for node in initial:
            for i, net in enumerate(gmap):
                if node in net:
                    count[i].add(node) 
                    break
        
        sums = sum([len(gmap[i]) for i in count])
        res = (initial[0], sums)
        print(count, sums)
        for node in initial:
            num = sums
            for i, net in count.items():
                if node in net and len(net) == 1:
                    num = sums - len(gmap[i])
                    break
            if num < res[1] or num == res[1] and node < res[0]:
                res = (node, num)
        return res[0]

'''
改革：
1. set累加，有一个总的set，替代一个visited 一个set的作用。
2. 本人最多=总数-本人最少。所以不用知道总数，只用知道本人个数就行了。
'''

class Solution(object):
    def minMalwareSpread(self, graph, initial):
        def dfs(node,vis):
            for v in  range(len(graph[node])):
                if graph[node][v] == 1 and v not in vis:
                    vis.add(v)
                    dfs(v,vis)

        s = set(initial)
        t_vis = set()
        del_node, subgraph_len = min(initial), 0
        for node in range(len(graph)):
            if node not in t_vis:
                vis = set([node])
                dfs(node,vis)
                # caculate the number of infected node in the subgraph
                infect = vis & s
                if len(infect) == 1:
                    # more number of nodes or smaller index
                    if len(vis) > subgraph_len or (len(vis) == subgraph_len and list(infect)[0] < del_node):
                        del_node,subgraph_len = list(infect)[0],len(vis)
                t_vis |= vis
        return del_node
