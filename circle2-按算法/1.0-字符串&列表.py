———————————————— NO.1 数组/字符串 ————————————————
http://micili.cn/2017/09/24/Leetcode%E6%80%BB%E7%BB%93-%E4%B8%80/

轴向重叠 56 

子串 686 459 28 14 763 
回文子串：647 5 516
https://leetcode.cn/problems/palindromic-substrings/solution/liang-dao-hui-wen-zi-chuan-de-jie-fa-xiang-jie-zho/
找所有回文子串的方式：对每个字符分奇偶两种情况，分别计算以它为中心的回文个数，和以它和它下一个为中心的回文个数，然后算和

子序列增减排序：300 334 665 670 1574 581
655 和 670 ：一个需要修改本值（or曰删除），一个是交换两个值
两个题都需要考虑更改了需要更改的值之后，剩下的值之间仍然存在比较，有可能不成立的问题。

在list里找东西O（n）：41 442 448
加减乘除及括号：43 224 227 {772} 856 1249
合并数组：88 324 
字符串比较大小：809 
单调栈： 239 *84 85 636 503
队列：862 
hashmap: 792
桶排序 164

string：
3 5 22 6 13 38 17 93 10 72 20 415 14 67 12 43 521 557 32 30 632 541 76 214 564 28 657 647 344 97 49 583 8 87 58 71 385 929 804 91 65 730 345 383 556 696 459 686 336 539 443 115 434 680 537 553 606 678 273 520 68 227 165 387 468 126 522 551 527 151 591 722 186 736 609 1065 555 159 1297616 1371 249 544 271 293 157 161 340 635 158 681 536 408
array:
1 4 15 53 42 11 85 16 31 26 717 59 78 39 121 45 88 18 64 56 118 561 167 128 120 169 48 442 289 105 238 41 287 621 718 54 941 747 122 560 448 75 628 66 33 55 27 283 62 216 79 689 695 697 268 152 35 229 123 119 90 84 189 209 57 1217 665 34 661 153 217 667 73 219 40 714 81 581 495 162 905 611 106 1013 63 565 414 228 485 566 670 870 713 643 80 280 605 719  950 74 126 154 1329 729 644 674 548 381 532 457 962 1031 245 724 1002 380 954 1386 163 370 243 277 259 1074 562 533 978 1287 723 624 531 1232 
hashmap：
1 535 3 85 37 94 739 18 136 202 349 463 30 632 718 76 500 187 560 447 49 138 409 690 204 347 525 726 36 454 1044 781 594 389 336 149 217 290 242 219 274 350 575 205 299 438 645 355 508 720 166 648 1001 387 451 554 676 692 966 711 381 599 609 244 380 311 325 159 314 359 694 358 249 288 734 340 266 624 170 356 246

好题：735 670 792 581 735 41

448 空间O（1）：在原数组的数上加长度 或者变负数
859[E] 规律：①如果不等，必须两个可以互换。②如果相等，必须有重复字符
628[E] 三个数（有正负）相乘要最大，答案在最大的三个数相乘，和最小的两个数与最大数相乘之间。（可以不sort，直接遍历找到这些数）
1576[E] 只需要3种字符abc就可以完成整个的替换。总是替换成前一个字符的下一个字符，如果该字符等于后一个字符，那么替换为后一个 字符的下一个字符。这样的替换不会出现矛盾，因为？总是可以选择一种字符来替换，且不会产生冲突
409[E]:可以拼的最长回文，奇数个的char不是整个都不能用！而是可以-1再全部用进去

———————————————— NO.2 滑动窗口/双指针 ————————————————

滑动窗口: 3, 15, 16, 42, 76, 81, 209, 424, 475, 904, 1004, 1052, 1208, 1438, 1493, 1574, 2024||1375 1099 382

http://micili.cn/2017/09/25/Leetcode%E6%80%BB%E7%BB%93-%E4%BA%8C/
406 283 75 15 259 42 407 443 532 640 3 680 481 487 264 313 522 360 524 159 340 287 838 243 244 245 675 1229 1099

🛑两个指针的使用方法：
	1. 固定一个端点对另一个进行二分
	2. 双指针。双指针有两种
		a. 滑动窗口
		b. 对撞指针

🟡最小滑窗模板：76, 438, 209,
给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最小长度。

while j < len(nums):
    判断[i, j]是否满足条件
    while 满足条件：
        不断更新结果(注意在while内更新！)
        i += 1 （最大程度的压缩i，使得滑窗尽可能的小）
    j += 1


🟡最大滑窗模板：904，1004，3
给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最大长度。

while j < len(nums):
    判断[i, j]是否满足条件
    while 不满足条件：
        i += 1 （最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）
    不断更新结果（注意在while外更新！）
    j += 1
 

🟡 滑动窗口长度不变
如果滑动窗口长度不变，比较里面char的频次，可以直接比较map：567


👉👉👉滑动窗口进化

https://leetcode.cn/problems/max-consecutive-ones-iii/solution/jidao-by-iamysw-bs2s/

1. 在求最长时，内部不用while，只用if。
	因为要求最长，比当前短的就不用缩进去了，如果比当前长才考虑增加。最后返回j-i
	如果窗口右端加入新元素后不满足要求则移除窗口左端的元素，左端口向前移动一步，同时更新变量、
	哈希表或有序集合。这个过程可以看出如果当前窗口不满足要求则左端口和右端口同时向前移动，
	且窗口大小保持不变，如果后续遇到了能满足要求的更大的窗口则左端口就停止移动，
	最后得到的窗口大小即是满足题目要求最大的窗口大小。
	🟡模板：
	while r < len(nums):
    	判断[l, r]是否满足条件
	    if 不满足条件：
	        l += 1  
	    r += 1
	return r - l
	注意初模板是r-l+1，因为是当下计算的，这个是r-l，因为是不满足移出去了才计算的。

	另外，这个方法能行得通的前提是：右端口开始移动时满足题目条件，
	但当右端口移动到某个位置之后不满足题目条件，且此时右端口就算继续向前移动也不能使窗口内满足条件。
	比如（LC525）就不能用这个方法：连续数组，因为不满足上诉前提。


2. 上面那个模板的前提是，改变条件改变至特定的一种。比如把1改变成0。
	如果需求是可以改变多个，在其中选最长/短的一个。两种方法：
	① 在外层遍历所有改变的目的值，比如遍历26个字母（LC424），遍历1/0，T/F（LC2024）
	② 把标记的count改成dic，随滑动随更新最终结果值（LC424、LC904）

	另外，在判断不满足条件之前update最新结果值可能更好理解一点。


———————————————— NO.3 前缀和/区间和 ————————————————

https://leetcode.cn/circle/discuss/SrePlc/

基础前缀和：303, 304 
频数前缀和：1177，1862
单调队列/栈维护：1124, 862,
Hash维护：{325}，525，1371，1542，560，1248，523，974，1590，1524
二维前缀和：1074，363，1292，1314，1139
前缀积：152，1352，
前缀异或：1310，1442，1738
前缀+后缀：238，724，838，828
前缀+dp:837,1444,1477，926，1478,1871
差分：56，370，1109，
其它：1381，689

523, 560, 930, | 974 238 121 122 525 1844 1840 404

前缀和  比如index2到index5，就是preSum5 - preSum1。
	   当preSum多一位，index为0的时候，前n项和在preSum里的index是n+1.
	   那么index2到index5表达式是 preSum[6] - preSum[2]

初始的dic的初始值：视乎dic的value是什么值
523：{0：-1}，此题的map.value代表index，意思是和为0时index为-1
974：{0：1}，(此题的map.value代表和为该key的个数，为什么这里是1，因为题目的意思是，如果余其他值，有两个以上同余才设答案，但是如果不余，本身就算答案，即一次也可以。所以余0的情况从1开始标记
			如果把题目改成，至少要两个数的子列，就不能设1了)
	value代表个数时，相当于给开头加[0],则有{0:1}


求区间和：
	https://leetcode.cn/problems/corporate-flight-bookings/solution/gong-shui-san-xie-yi-ti-shuang-jie-chai-fm1ef/
	【最佳方案】
	数组不变，区间查询：【前缀和】、树状数组、线段树；
	数组单点修改，区间查询：【树状数组】、线段树；
	数组区间修改，单点查询：【差分】、线段树；
	数组区间修改，区间查询：【线段树】。


———————————————— NO.4 二分 & 分治 ————————————————
https://github.com/azl397985856/leetcode/blob/master/thinkings/binary-search-1.md

http://micili.cn/2017/10/15/Leetcode%E6%80%BB%E7%BB%93-%E4%B8%89/
基于index，基于值，基于数据结构
278 744 34 74 240 378 153 154 33 81 50 162 275 
436 410 658 300 483 327 315 475 540 528 1385

dp+dinary:410 300
https://darktiantian.github.io/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%E7%AF%87%EF%BC%89Binary-Search/
35 153 34 278 374 744 852 1014 875 1145 33 81 1283 1268 392 1482 1201 287 154 1539 1552 162 1095 74

感觉是好题：528 540 475 315 300 658 （410）
 
一般如何辨别一道题能用二分，我总结了一些规律

1. 首先拥有连续的序列
2. 能够通过暴力O（n）O（n）的方法是搜索出答案
3. 该序列具有二段性


🟡 基于index：

· 如果使用left < right，那么必须使用left = mid + 1，避免死循环以及结合right = mid，防止跳过答案，但是要防止left做结果的情况。

	需要最后才得知答案的使用这种方式。

· 如果使用left <= right做判断。必须使用right = mid - 1来避免，因为left可能等于right，这样mid永远等于left和right，会死循环。
	还要注意如果len长度为1，初始化的时候，right = -1 < left = 0

	如果可提前锁定答案return 可使用这种方式。

	这里跳出循环后，left和right代表的值：
	如果循环里判断L的循环是：if target < a[mid]: L = mid + 1 else
	最后 状态就是 a[R]<target<=a[L]

· 使用left + 1 < right做判断。 这样竟然就可以使用left = mid，这是因为left永远是比right要小2的，所以每次算出来mid都会比left大1。
  另外，left + 1 < right相比于left < right。最终的left和right必然指向不同的两个相邻index，后者最后left和right指向同一个元素。

  left + 1 < right也存在自身缺点：
  如果一开始只有两个元素，且left、right一开始指向的元素就不合法，那么就不能明确的知道left指向的是答案，还是right指向的是答案了。不同于使用left <= right就可以避免一开始left和right有可能不合法的问题

二分搜索的测试用例：
	① 是否输入有序 
	② target在输入的两侧 
	③ target在输入的中间
	④ 输入的元素只有一个（是target或者不是target）
	⑤ 输入的元素有两个（包含target、不包含target）
	⑥ 输入元素有多个
	⑦ 上面几种的组合。

lower_bound: x >= t 中最小的x，所谓最小也就是从小到大排序中最靠近左侧的； 
upper_bound: x > t 中最小的x。如果不存在x > t，那么返回最后一个下标。 
例如：10 10 10 20 20 20 30 30； 20的lower_bound是第一个20，upper_bound是第一个30。

 
🔺最小的i，a[i] = key：
	l < r 
	m = l + ((r - l) >> 1) # 向下取整
	if a[m] < key l = m + 1 else r = m
🔺最大的i，a[i] = key：	
	l < r 
	m = l + ((r - l + 1) >> 1) # 向上取整
	if a[m] <= key l = m else r = m - 1
🔺最小的i，a[i] > key：
	l < r  
	m = l + ((r - l) >> 1) # 向下取整
	if a[m] <= key l = m + 1 else r = m
🔺最大的i，a[i] > key：
	l < r  
	m = l + ((r - l + 1) >> 1) # 向上取整
	if a[m] <= key l = m else r = m - 1

bisect.left: a[mid] < key, lo = mid + 1 else hi = mid
bisect.right : a[mid] <= key, lo = mid + 1 else hi = mid


🟡 基于值：

是求第k，前k。
方式：
	找出值的上限和下限。再找出中值，再缩减。同时统计搜索的数量，和k比较大小。
	如果搜索到的数量是小于k的，那么M不够大；反之，M太大；
	最后，如果M缩减到一个点的时候（注意不存在提前返回），就可以说，M就是答案。


分治  
def sort(nums,  lo,  hi):
    mid = (lo + hi) / 2
    sort(nums, lo, mid)
    sort(nums, mid + 1, hi)
    merge(nums, lo, mid, hi)


———————————— NO.5 单调栈 & 单调队列 —————————————— 
76 239

394 

保持栈里的元素单调递升或递减，如果违反则弹出
* 判断的时候，要分清0存在，还是为空
503 ： 因为stack[-1]可能为0，这时stack and stack[-1] 为false
❌ res = stack and stack[-1] or -1
✔ if stack: res = stack[-1]


按位数比大小的题，用单调栈。
https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-6/
思想是：当前的值与stack[-1]比较，判断的不是当前值，而是stack[-1]  ❗ ❗ ❗
决定要不要删除stack[-1],与全局有关。
依题目，有的题给了全局个数k，那么删完为止。（因为从左到右遍历，越早删的越大，所以先删，删完为止）
有的题，每个字母有自己限制的个数，那么每轮需要判断它能不能删，超没超它的个数。那么全局先要统计一次每个字母的个数

排列最大值题：316，321，402，1081 （179）




————— 分治 —————
** 912
*** 315

————— 双指针 —————
*** 992 
925 986